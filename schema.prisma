// Prisma Schema Definition
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [cube, earthdistance]
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Basic Info (anonymous)
  pseudonym String   @unique
  ageRange  String   // '25-30', '30-35', etc.
  locationLat Float?
  locationLon Float?
  searchRadiusKm Int  @default(50)

  // Authentication
  emailHash    String  @unique
  passwordHash String

  // Status
  isVerified Boolean @default(false)
  isActive   Boolean @default(true)
  lastActive DateTime?

  // Privacy
  privacyLevel                   Int     @default(3)
  revealPhotoAfterMatch          Boolean @default(true)
  revealSensitiveTagsAfterMatch  Boolean @default(true)

  // Relations
  photos       UserPhoto[]
  tags         UserTag[]
  personality  UserPersonality?
  preferences  UserPreferences?
  matchesAsUser1 Match[] @relation("user1")
  matchesAsUser2 Match[] @relation("user2")
  sentMessages   Message[]

  @@index([locationLat, locationLon])
  @@index([isActive])
  @@index([lastActive])
  @@map("users")
}

model UserPhoto {
  id        String   @id @default(uuid())
  userId    String
  photoUrl  String
  photoType String   // 'object', 'face', 'body'
  orderIndex Int     @default(0)

  // Object recognition
  detectedObjects    Json?    // [{object: "whip", confidence: 0.95}]
  suggestedTags      Json?    // [{tagId: "bdsm.impact.whip", confidence: 0.92}]
  userConfirmedTags  String[] // Array of confirmed tag IDs

  isPrimary  Boolean  @default(false)
  isNsfw     Boolean  @default(false)
  uploadedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([photoType])
  @@map("user_photos")
}

model UserTag {
  id       String   @id @default(uuid())
  userId   String
  tagId    String   // e.g., 'bdsm.dominance.strict_mistress'
  tagType  String   // 'must', 'nice', 'interest', 'limit'
  intensity Int?    // 1-5 scale
  role     String?  // 'active', 'passive', 'both', 'viewer'
  isPublic Boolean  @default(true)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tagId])
  @@index([tagId])
  @@index([userId])
  @@index([tagType])
  @@map("user_tags")
}

model UserPersonality {
  userId String @id

  // Big 5 Personality (0-100 scale)
  openness          Int?
  conscientiousness Int?
  extraversion      Int?
  agreeableness     Int?
  neuroticism       Int?

  // Generated Character
  archetypeId          String?
  archetypeName        String?
  archetypeDescription String?  @db.Text

  // Lifestyle, Interests, Values, Aesthetics (as JSON)
  lifestyle      Json?
  interests      Json?
  values         Json?
  aesthetics     Json?
  communication  Json?
  availability   Json?

  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_personality")
}

model UserPreferences {
  userId String @id

  // Seeking
  seekingGender  String[] // ['male', 'female', 'non_binary', 'all']
  seekingAgeMin  Int?
  seekingAgeMax  Int?
  seekingRole    String[] // ['dom', 'sub', 'switch', 'vanilla_open']
  seekingIntent  String[] // ['relationship', 'play_partner', 'casual', 'friendship']

  // Must-have filters (AND logic)
  mustHaveTags String[]

  // Nice-to-have (OR logic, weighted)
  niceToHaveTags String[]

  // Deal-breakers (NOT logic)
  dealBreakerTags String[]

  // Personality preferences (optional)
  preferExtraversionMin Int?
  preferExtraversionMax Int?

  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Match {
  id String @id @default(uuid())

  user1Id String
  user2Id String

  // Match scoring
  overallScore     Decimal @db.Decimal(5, 2)
  fetishScore      Decimal @db.Decimal(5, 2)
  personalityScore Decimal @db.Decimal(5, 2)
  lifestyleScore   Decimal @db.Decimal(5, 2)
  valuesScore      Decimal @db.Decimal(5, 2)
  aestheticsScore  Decimal @db.Decimal(5, 2)

  // Status
  status          String  @default("pending") // 'pending', 'accepted', 'rejected', 'expired'
  user1Interested Boolean @default(false)
  user2Interested Boolean @default(false)

  // Reveal stages
  user1RevealedPhoto     Boolean @default(false)
  user2RevealedPhoto     Boolean @default(false)
  user1RevealedSensitive Boolean @default(false)
  user2RevealedSensitive Boolean @default(false)

  matchedAt DateTime  @default(now())
  expiresAt DateTime? // Auto-expire after 7 days if no response

  user1    User      @relation("user1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("user2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@index([status])
  @@index([matchedAt])
  @@map("matches")
}

model Message {
  id      String @id @default(uuid())
  matchId String
  senderId String

  // Message content (encrypted at rest)
  messageType      String  @default("text") // 'text', 'template', 'reveal'
  contentEncrypted String  @db.Text
  templateId       String? // For pre-defined question templates

  isRead Boolean  @default(false)
  sentAt DateTime @default(now())

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([sentAt])
  @@map("messages")
}
